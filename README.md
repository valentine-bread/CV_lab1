# Лабораторная работа 1

## Теоретические сведения.
Размытие по Гауссу является усредняющем фильтром. Широко используется для уменьшения шума изображения и уменьшения детализации. Выполняется путём свёртки изображения с ядром фильтра.
Ядро фильтра – одномерная(n) или двумерная(n*n) матрица коэффициенты которой рассчитаны по формуле. 

Для одномерной:
[![Формула 1](https://wikimedia.org/api/rest_v1/media/math/render/svg/dd16b16869269dba008d19c0969515a1d50b3ae2)]

Для двумерной:
[![Формула 2](https://wikimedia.org/api/rest_v1/media/math/render/svg/6717136818f2166eba2db0cfc915d732add9c64f)]

Нормализующий множитель при свёртке – сумма всех коэффициентов ядра. 
Размытие с одномерным ядром выполняйся в два прохода, сначала свёртка с ядром расположенным вертикально, а затем результат первой обработки и ядром расположенным горизонтально.  

## Описание разработанной системы
Фильтр реализуется 3 способами:
- Реализованный вариант из библиотеки OpenCV
- В виде функции на языке Python 
- В виде функции компилируемой функции с использование компилятора Namba 

Все реализованные функции имеют приблизительно одинаковую структуру.
Функция генерации ядра свёртки:
```python
kernelRadius = int((kernel_size - 1) / 2)   #вычисление радиуса фильтра по его размеру 
karnel = np.zeros(kernel_size)              
karnel_sum = 0                              #сумма коэффициентов фильтра 
for i in prange(kernel_size): 
    x = np.exp(-((i - kernelRadius)**2)/(2*sigma**2)) / np.sqrt(2*np.pi*sigma**2)#Вычисление коэффициентоа
    karnel[i] = x                           
    karnel_sum += x
for i in prange(kernel_size):
    karnel[i] = karnel[i] / karnel_sum      #нормирование ядра свёртки
return karnel
```
Функции свёртки:
```python
for channel_i in prange(channel):                           #каналы 
        for width_i in range(width):                        #пиксели по ширене 
            for height_i in range(height):                  #пиксели по высоке
                sum_pix = 0                                 #сумма свёртки
                for i in range(kernel_size):
                    for j in range(kernel_size):
                        h = height_i - kernelRadius + i     #текущий пиксель в свёртке
                        w = width_i - kernelRadius + j      #
                        sum_pix += img[abs(h) if h < height else 2*height - h - 1][abs(w) if w < width else 2*width - w - 1][channel_i] * karnel[i][j] #умножение ядра на пиксель + проверка границ
                img[height_i][width_i][channel_i] = sum_pix #присвоение значения пикселю
```


Для GUI испотзуется графическая библиотека PyQt5. 
GUI позволяет выбрать способ обработки и размер ядра фильтра. По нажатию кнопки 'Original' выводится исходное изображение, по нажитою кнопки 'Processed' происходит обработки изображения и его вывод на экран. В статус бар выводиться обработки изображения с заданными параметрами.

[![Изображение GUI]()]

## Результаты работы и тестирования системы 
Результат работы всех 3 алгоритмом практически идентичен.

[![Зависимость 1](/screen/5.png)]
[![Зависимость 2](/screen/6.png)]

В зависимости от размере ядра фильтра пропорционально меняется и время обработки изображения.
[![Зависимость 1](/screen/1.png)]
[![Зависимость 2](/screen/2.png)]

Также время работы зависит и от размеров исходного изображения.
[![Зависимость 3](/screen/3.png)]
[![Зависимость 4](/screen/4.png)]

## Источники 
- https://habr.com/ru/post/484136/
- https://docs.opencv.org
- https://numba.pydata.org
- https://en.wikipedia.org/wiki/Gaussian_blur

